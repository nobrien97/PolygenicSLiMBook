// Generate PBS script based on SLiM input and parameters
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <random>
#include <sstream>
#include "getopt.h"
#include "generators.hpp"

using std::string;
using std::vector;

// Define class member functions

void FileGenerator::FileGenerate() {}

// Fix name by attaching PBS string
string FileGenerator::NameWrap(const char *input) 
{
  string str(input);
  str = "#PBS -N " + str;
  return str;
}

  // Append G to memory value to appease the PBS system
string FileGenerator::MemG(const char *input)
{
  string str(input);
  str = str + "GB";
  return str;
}


void FileGenerator::file_save(const vector<string> &file, const string filename)
{
  std::ofstream outfile(filename);

  for (int i = 0; i < file.size(); ++i)
  {
    outfile << file[i] << "\n";
  }
}

PBSGenerator::PBSGenerator(const FileGenerator &FG)
{
  PBS_SetVars(FG);
}

void PBSGenerator::FileGenerate()
{
  _jobname += "\n";
  _walltime = "#PBS -l walltime=" + _walltime;

  if (_nimrod == false)
  {
    // Add \n to options

    // Set up the script with the first few necessary parts of the script
    vector<string> scriptLines = {_bashreq, _jobname, _walltime};
    // Add the cores and memory
    string coresMem = "#PBS -l select=1:ncpus=" + std::to_string(_cores) + ":mem=" + _mem;
    scriptLines.emplace_back(coresMem);

    if (_jobarray.size())
    {
      string jobArrString = "#PBS -J " + _jobarray;
      scriptLines.emplace_back(jobArrString);
    }

    string scriptSetup = "\ncd $TMPDIR\nmodule load R/3.5.0\nSECONDS=0\n";
    scriptLines.emplace_back(scriptSetup);

    string sublaunchR = "\nR --file=" + _filename + ".R\n";
    scriptLines.emplace_back(sublaunchR);

    vector<string> outputStrings = {"out_stabsel_means.csv",
                                    "out_stabsel_muts.csv",
                                    "out_stabsel_burnin.csv",
                                    "out_stabsel_opt.csv",
                                    "out_stabsel_dict.csv",
                                    "out_stabsel_pos.csv"};

    for (const string &str : outputStrings)
    {
      scriptLines.emplace_back("cat /$TMPDIR/" + str + " >> /30days/$USER/" + str);
    }

    string timer = "\nDURATION=$SECONDS";
    scriptLines.emplace_back(timer);
    string timeLine = "echo \"$(($DURATION / 3600)) hours, $((($DURATION / 60) % 60)) minutes, and $(($DURATION % 60)) seconds elapsed.\"";
    scriptLines.emplace_back(timeLine);

    // Add a cool(tm) advertisement
    scriptLines.insert(scriptLines.begin()+1, "\n# This code was generated by SLiM Runner: https://github.com/nobrien97/PolygenicSLiMBook/tree/main/src/Tools\n");

    file_save(scriptLines, _filename + ".pbs");
  }
  else {
    // Write a Nimrod script instead
    vector<string> scriptLines = {_bashreq, _jobname, _walltime};
    // Attach ompthreads and nodes to cores/memory info as well
    string coresMem = "#PBS -l select=" + std::to_string(_nodes) + ":ncpus=" + std::to_string(_cores) + ":mem=" + _mem +":ompthreads=1";
    scriptLines.emplace_back(coresMem);
    // Add this line because it needs to be there for nimrod to work
    scriptLines.emplace_back("#NIM shebang /bin/bash");

  // Add parameters
    string nimPars =  "#NIM parameter LS integer range from 1 to "+ std::to_string(_comboSize) + " step 1\n#NIM parameter SEED integer range from 1 to 50 step 1\n"; 
    scriptLines.emplace_back(nimPars);

    scriptLines.emplace_back("if [ -z \"${NIMROD_VAR_LS}\" ]; then\n"
                              "\t\t\t\techo \"\$NIMROD_VAR_LS isn't set, cannot continue...\"\n"
                              "\t\t\t\texit 2\n"
                              "fi");

  scriptLines.emplace_back("if [ -z \"${NIMROD_VAR_SEED}\" ]; then\n"
                              "\t\t\t\techo \"\$NIMROD_VAR_SEED isn't set, cannot continue...\"\n"
                              "\t\t\t\texit 2\n"
                              "fi");

  
  }
}
    void PBSGenerator::PBS_SetVars(const FileGenerator &FG)
    {
      this->_filename = FG._filename;
      this->_bashreq = FG._bashreq;
      this->_jobname = FG._jobname;
      this->_jobarray = FG._jobarray;
      this->_walltime = FG._walltime;
      this->_cores = FG._cores;
      this->_mem = FG._mem;
      this->_parameters = FG._parameters;
      this->_verbose = FG._verbose;
      this->_nimrod = FG._nimrod;
      this->_r_only = FG._r_only;
      this->_pbs_only = FG._pbs_only;
    // If we're nimrod, set a few values differently
      if (FG._nimrod) {
        NSH_SetVars(FG);
      }
    }

    void PBSGenerator::NSH_SetVars(const FileGenerator &FG)
    {
      this->_bashreq = "#!/sw7/RCC/NimrodG/embedded-1.9.0/bin/nimexec\n#PBS -A qris-uq\n#PBS -q workq";
      this->_comboSize = FG._comboSize;

    }

    RGenerator::RGenerator(const FileGenerator &FG)
    {
      R_SetVars(FG);
    }

    void RGenerator::FileGenerate()
    {
      if (_nimrod == false)
      {
        vector<string> RScriptLines = {"# Code generated by SLiM Runner: https://github.com/nobrien97/PolygenicSLiMBook/tree/main/src/Tools/SLiMRunGen\n"
                                       "USER <- Sys.getenv('USER')\n",
                                       "library(foreach)\nlibrary(doParallel)\nlibrary(future)\n",
                                       "cl <- makeCluster(future::availableCores())\n",
                                       "registerDoParallel(cl)"};

        RScriptLines.emplace_back("seeds <- read.csv(\"" + _seeds_dir + "\", header = T)");
        RScriptLines.emplace_back("combos <- read.csv(\"" + _combos_dir + "\", header = T)");
        std::stringstream ss(_parameters);
        vector<string> params;

        while (ss.good())
        {
          string substr;
          std::getline(ss, substr, ',');
          params.emplace_back(substr);
        }

        RScriptLines.emplace_back("foreach(i=1:nrow(combos)) %:%\n"
                               "\tforeach(j=seeds$Seed) %dopar% {\n"
                               "\t\tslim_out <- system(sprintf(\"/home/$USER/SLiM/slim -s %s "
                               );

        /* Add SLiM parameter list into a single command line string: 
    treating all variables as strings for feeding into sprintf, should be fine */
        string slimParamList;

        for (string param : params)
        {
          slimParamList += "-d " + param + "=%s ";
        }
        slimParamList = slimParamList + _slim_path + "\"";
        string rParamList;

        for (int i = 0; i < params.size(); ++i)
        {
          rParamList += "combos[i,]$" + params[i] + ", ";
        }

        // Attach the parameter list to the end, as well as the slim directory
        *(RScriptLines.end() - 1) += slimParamList + ", " + "as.character(j), " + rParamList + "intern=T))";
        RScriptLines.emplace_back("  }\n"
                               "stopCluster(cl)");
        file_save(RScriptLines, _filename + ".R");
      }
    }

    void RGenerator::R_SetVars(const FileGenerator &FG)
    {
      this->_LHC = FG._LHC;
      this->_LHC_dir = FG._LHC_dir;
      this->_seeds_dir = FG._seeds_dir;
      this->_parameters = FG._parameters;
      this->_verbose = FG._verbose;
      this->_nimrod = FG._nimrod;
      this->_slim_path = FG._slim_path;
      this->_r_only = FG._r_only;
      this->_pbs_only = FG._pbs_only;
      this->_combos_dir = FG._combos_dir;
    }
